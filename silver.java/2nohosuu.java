Q.byte a = (byte) 0b100000000;
この式がコンパイルエラーにならない理由を教えてほしい
値は128になるのでbyteの範囲外になると思いました

A.🔹 byte の範囲
Javaの byte 型は 8ビット で、表現できる値の範囲は -128 から 127 です。

🔹 byte の負の値の扱い（2の補数表現）
Java の byte は 符号付き整数 で、負の値は 2の補数表現 で表されます。
0b10000000 は 負の数として解釈される のです。

2の補数表現では：0b10000000（8ビット） = -128（10進数）

🔹 そもそも 2の補数表現とは？
Java の byte 型（8ビット）は、2の補数（Two’s Complement） 
という表現方法を使って負の数を扱います。

ポイント：最上位ビット（MSB: Most Significant Bit）は符号ビット
0 → 正の数
1 → 負の数
負の数は、2の補数を使って表される
2の補数とは、ビットを反転（1 → 0, 0 → 1）し、1を足したもの

Q.なるほど、この2の補数が適用されるのは8bitだけですか？
それとも何bitでも最上位ビットは正か負を表すのですか？

A.2の補数表現は、何ビットでも適用されます！ ただし、「符号付き整数型」 に限ります。
🔹 2の補数は何ビットでも適用される？
✅ 結論：どんなビット数でも、符号付き整数なら最上位ビット（MSB）は符号を表す
例えば、Java では byte(8bit)、short(16bit)、int(32bit)、long(64bit) の
すべてが 2の補数 を使います。

🔹 例外：符号なし整数（unsigned int）
char 型（16ビット）は 符号なし整数（0 ～ 65535） なので 最上位ビットは符号を表しません！
char c = 0b1000000000000000; // 32768（負の数にはならない）
→ char は 2の補数を使わないので、単純な2進数として扱われる;